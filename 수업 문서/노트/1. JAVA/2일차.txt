메소드 =  명령어를 내포하고 실행하는 공간(함수)
1일차와(void) 다르게 2일차에선 public이 메소드를 선언하는 것으로 보임

void는 return값이 없다는 것

4바이트가 컴퓨터가 계산하기 최적화되어있음 => int가 기본값
double은 실수의 소숫점 유효범위를 높이기 위해서 기본값으로 된 것.


★스트링 뒤에 붙는 숫자는 모두 문자처리됨.
	- 스트링(문자열) 뒤에 붙는 숫자들 끼리 연산하고 싶을 경우 숫자끼리 (괄호)쳐주어 연산순위를 높인다.

★스트링 앞에 있는 숫자는 모두 숫자처리됨.


2진수 비트로 계산하는 컴퓨터 특성상 한정된 비트를 초과하는 ★오버플로우가 발생할 경우
최솟값으로 돌아가게 된다. 01111111 의 다음값(+1) 은 10000000으로 음수 최대값(최솟값)이 됨.


패키지와 클래스를 만들땐 기능부와 실행부를 별도로 만들어야 한다.
기능부가 실행부에 전부 때려박아져 있으면, 구동속도가 많이 느려진다(static 메모리 차지 그런듯)
그러니 Run 패키지와 Variable 패키지를 따로 만든다

자동 형 변환은 바이트 사이즈가 같거나, 작은것에서 큰것으로 갈 때 가능

특수하게 long(8바이트)에서 float(4바이트)로 갈 때도 형 변환이 가능하다.
실제 크기는 실수가 정수보다 훨씬 크게때문에(소숫점 계산 과정 중 커진다)
실수의 byte가 정수의 byte보다 작더라도 받을 수 있음

Long에서 리터럴에 L을 붙이지 않아도 숫자 리터럴의 기본값인 int가 long으로 자동형변환이 되어 문제없이 돌아간다.
반대로 int범위를 벗어난 숫자는 오버플로우가 발생할 수 있으므로 long으로 처리하라는 l을 붙여야한다. 

자동 형변환 : 아무짓도 안해도 변하는 형 변환
	작은 자료형을 큰 자료형으로 변환할때 발생
강제 형변환 : 인위적으로 변해줘야 하는 형 변환
	바이트 앞부분을 강제로 늘리거나 날려 작은 바이트 자료형에 꾸겨넣는것
	형 변환 잘리는 부분이 있을 경우 데이터 손실 발생


같은 메소드에는 다른 변수를 써야한다 안그럼 꼬여
다른 메소드에는 같은 변수를 써도 됨. 결과값만 다르면 되니까

변수가 생성되면 Stack 메모리에 저장된다.
Stack 메모리는 메소드 사용시 불러와서 잠시 저장 후 메소드 실행이 끝나면 자동 삭제된다.
지역변수, 매개변수 등 해당

print : 줄바꿈 기능 없음
println :ln은 line을 뜻한다. 줄바꿈 기능이 있다.
printf : f는 format을 뜻함. 줄바꿈 기능 없음
format 안에서 쓸 수 있는 형식:
%d : 정수형,    %c : 문자,     %s : 문자열
%f : 실수,     %b : 논리형,     %g : 대입값 그대로

%o : 8진수,    %x : 16진수,    %e : 지수,     %A : 16진수 실수

ex) System.out.printf("%s 님은 %d 세이며, 키는 %f cm입니다.", name, age, height)
	-> 김대호 님은 30세이며, 키는 160 cm입니다
기존 지정되어있는 변수에 맞는 형식을 사용하여 출력

개발자 목표
1. 완성
2. 효율화 (중복제거)
	지역변수는 해당 메소드 안에서만 돌아감. 타 메서드로는 이동할 수 없으므로 전역변수를 만들어줘야함
	그러니까 메서드 안에 있는 변수를 클래스 레벨로 올리라고(전역변수) 그럼 해당 클래스 안에선 다 쓸 수 있싐
	전역변수 = 전체 영역 변수의 줄임말(영어로는 Filed = 맴버필드 = 맴버변수)

★★★지역변수에서 전역변수와 같은 변수명을 사용하여 변수 데이터값을 변화해도 전역변수 자체가 변하진 않는다.
ex) A 메소드에서 전역변수의 변수데이터를 지역변수로 선언하여 바꿔써도 B메서드에선 변화하지 않은 전역변수를 사용할 수 있다


★키보드 값 사용자로부터 입력받기
https://docs.oracle.com/javase/8/docs/api/
접속하면 자바 내 예약어들을 조회 가능. Scanner같은 경우 Java.util 패키지 내 Scanner 클래스에 있다.
위 설명 중 print와 같이 static 클래스로 지정되지 않았다면 객체로써 import가 필요함


import 부분 : import java.util.Scanner;

Scanner 생성 : Scanner sc = new Scanner(System.in);

자료형에 따른 키보드 입력 값 받는 명령어
정수 : sc.nextInt();
실수: sc.nextFloat(); or sc.nextDouble();
문자열 : sc.next(); or sc.nextLine();

이 중 nextLine() 을 제외하고는 버퍼로부터 줄바꿈을 빼고 값만 받아옴
nextLine()은 줄바꿈 까지 가져와서 값만 넣고 줄바꿈을 버림. 줄바꿈이 있으면 가져오면서 입력 종료로 인식.

print("이름 : ")
1. String name = sc.nextLine(); => 박신우\n를 모두 가져간 후 \n을 삭제하고 박신우만 값으로 넘김
			(\n이 남으면 끝났다 판단함)
2. String name = sc.next(); => 박신우\n에서 박신우 만 가져감 (buffer에는 \n 남아있음)

사용자로부터 값 입력받을 시 '박신우' 입력 후 엔터하면 박신우\n이 buffer에 입력됨
값이 buffer로 들어가고 buffer에서 name 변수에 값을 입력

만약 line 전에 다른 입력 명령어가 있어 \n이 남아있다면 \n이 있기 때문에 
nextLine은 입력이 끝난걸로 판단하여 \n만 가져온 후 이를 버리고 끝냄.
즉, 실행하지 않은것과 같은 효과

프로그램 실행시 우상단 상태창 네모가 빨강이면 아직 실행중이라는 의미. 클릭시 중지가능
상태창 검정색이면 실행할게 더 없다는의미



