--------------------------------------------------------------------------------------------------
한 클래스로 객체가 프로그램 실행시 n개가 생성된다면 (레퍼런스 변수명이 같더라도!)
n개의 주소가 있는것이기 때문에

특정 객체에 변화를 주어도 다른 객체는 독립적이다.

그러니까 여러 객체를 만들어도 각 객체는 첫 클래스의 초기화값을 갖는다
--------------------------------------------------------------------------------------------------
메소드 안에서 전역변수 값을 불러와서 변화시키면,

다른 메소드에서도 변화된 전역변수값이 적용된다 (당연한가;) (전역변수는 서로 공유되니까)
--------------------------------------------------------------------------------------------------
메소드안에서 처음 생성한 변수는(지역변수)

다른 메소드에서 사용 불가능하고 같은 변수명으로 생성해도 초기화된 전역변수로 적용된다
(당연한가;) (지역변수는 그 안에서만 쓰니까)

--------------------------------------------------------------------------------------------------
메서드에서 매개변수 있는 생산자로 객체 생성해서 전역 레퍼런스 변수에 집어넣으면,
 기존 레퍼런스 주소가 변화한다. (새로운 객체가 된다)
고로 새로운 객체에서 매개변수에 해당되지 않는 맴버 변수(필드)값은 default값으로 초기화된다.
--------------------------------------------------------------------------------------------------




객체 배열

객체 배열 안에 객체를 넣을떄는

객체를 생성해서 넣어줘야 하기 때문에 항상 new 생성자가 필요하다.
new로 객체가 생성되며 주소값이 나오고 해당 주소값이 배열의 인덱스에 들어감.

배열 생성할때도 new 를 써서 heap에 배열공간을 생성하듯이
★배열 인덱스에 들어갈 객체도 heap에 공간을 생성하기 때문에 new를 써야하는것!

Example[] arr = new Example[2];
arr[0] = new Example(1);
arr[1] = new Example(2);

Example[] arr = {new Example(1), new Example(2)};

여기서 Example[]은 arr의 자료형이고
Example은 클래스 명이고 new 연산자가 합쳐져 객체를 생성한다. 
고로 arr[0 or 1]은 Example 인스턴스의 레퍼런스값을 갖고 있다.
때문에 arr[0 or 1] . 으로 Example클래스의 요소들을 사용할 수 있다.
ex) arr[1].add()


객체 배열 생성시 배열 주소값이 배열명에 입력
1번 Example 객체 주소값이 arr[0]에 입력
2번 Example 객체 주소값이 arr[1]에 입력

배열 인덱스값마다 객체 주소가 들어간다.

배열주소값을 따라가고 해당 인덱스에 들어가면 있는 주소로 객체를 따라간다.

2차원 배열과 같은 프로세스지만 1차원 배열이다.
1 차원 배열에 자료값이 아닌 주소값이 있다보니까 비슷해보이는거다

클래스의 기본값은 null이다
String 도 클래스니까 기본값이 null인 것과 같다.