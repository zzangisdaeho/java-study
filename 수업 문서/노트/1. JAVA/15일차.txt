다형성

전제조건 = 상속
자식객체들을 부모타입의 자료형이 받아 줄 수 있다.
child c = new child(); 
=> parent c = new child(); 가능
모든 클래스는 오브젝트의 자손이므로 (Object 최상위)오브젝트 자료형이 다 받아줄 수 있다. (업 캐스팅)

-----------------------------------------------------------------------------------------------------------------------
업 캐스팅

Parent p = new Child();
부모 자료형으로 자식 개체를 받을 시 ,Child 객체 주소값을 p가 가져오지만,
자료형이 Parent이기 때문에 (Parent 안경을 썼기 때문에) 
★(char 가 문자열을 못보는것과 마찬가지. 자료형에 맞는 데이터만 들어가는 것과 같은 이치로 보면 됨)
(안그럴꺼면 자료형이 애초에 의미가 없잖슴 파이썬처럼 다 써버리면되지 그게안되니까 자바인것 ㅎ)
Child 객체 안의 Parent 영역의 기능만 보인다. (Child 클래스에서 새로 만든 변수나 기능은 사용할 수 없다)

다운 캐스팅 

레퍼런스 변수 p가 Parent 자료형이기 때문에 Parent만 보인다면
p를 Child 자료형으로 바꿔줄 시 Child p = new Child(); 처럼 사용 가능하다. (Child 안에 기능 쓸 수 있다)
다음과 같이 바꿀시 Child 안에 있는 childview() 메소드를 사용할 수 있다.
강제형변환과 비슷 (다운 캐스팅)
	★	((Child2)p).childview()

-----------------------------------------------------------------------------------------------------------------------

반대로 자식 자료형은 부모를 받을 수 없다.
자식 자료형의 사이즈를 부모 클래스가 채울 수 없기 때문. 
있는 소세지를 잘라서 먹을 순 있지만, 작은 소세지를 만들어서 먹을 순 없다.
(int 에서 double까지 커지는건 해당 기본 자료형이 특수하고 자동 형변환을 지원하기 때문이지 원래는 불가능한 일이다.)
없는걸 만들어서 볼 수는 없다.


String 은 문자 하나만 받을 수 있지만
char는 문자 두개 이상 (문자열) 받아들이지 못함
String 자료형은 Child고 char 자료형은 Parent라고 이해하면 될듯.



이 귀찮은 형변환을 하는 이유 :
	1. 객체 배열 : 부모 자료형으로 배열을 만들어서 자식 객체들을 다 담을 수 있다.
	2. 매개변수 : 메소드 매개변수에 Parent p 만 만들어놓고 (자료형 + 자료형 이름)
		추후 사용시 매개변수에 객체를 생성해서 넣어줄 수 있다.
		ex) info(Parent p){}
			-> info(new Child1);
			-> info(new Child2);
			-> info(new Child3);
		
		배열 선언시 int[] a; 처럼 자료형만 만들어놓고 (자료형 + 자료형 이름)
		추후 사용시 a = new int[5] 처럼 객체를 만들어주는것과 비슷함.
		
		매개변수 있는 메소드 제작시 (int a, String b) 로 만들어놓고
		추후 사용시 메소드(a , b)로 타입에 맞는 자료형 넣어주는것과 비슷함!


Parent[] pArr = new Parent[4];
	Parent 자료형을 가진 pArr 레퍼런스변수에 Parent가 들어갈 수 있는 4개의 공간을 만들어 주소값을 넘긴다

	Parent가 들어갈 수 있는 공간에는 자식클래스가 들어갈 수 있다. (업 캐스팅)
	하지만 Parent 자료형이기에 Child안에 있는 Parent 영역만 보이기 때문에
	instanceof 를 사용하여 Parent 자료형을 Child자료형으로 바꿔준당.


Parent[] pArr = new Child1[4]
pArr[0] = new Child1(); => Child1을 온전히 볼 수 있나? 안됨. why? pArr주소값이 Child1이라는 배열 틀의 주소값과 자료형이 일치하지 않기 때문.
자료형 인덱스와 객체의 자료형은 일치하지만 배열 틀의 주소가 Parent와 일치하지 않는다. 누적이 생겨서 참조할 수 없다.
pArr[1] = new Child2(); => pArr[1] 은 Child1형으로 Child2 못들어감(상속관계 없음)



동적 바인딩 :
	상속관계로 다형성이 적용된 경우 자식이 오버라이드하면 해당 메소드는 오버라이드된 자식의 메소드에 우선권
	(형변환 해주지 않아도 부모도 같은 메소드가 있기 때문에 볼 수 있다)
	자식이 오버라이드 안하면 부모의 메소드를 실행




추상 메소드를 포함하고 있는 클래스를 추상 클래스라고 부름

추상메소드가 있으면 추상클래스인데 추상클래스에 추상메소드가 반드시 있는건 아니당(클래스 선언으로만 추상클래스를 만들수도 있다).
그러니까 추상클레스엔 일반메소드도 들어갈 수 있다.

추상 메소드 = 몸체 없는 메소드 = 중괄호 {} 가 없다. (abstract 키워드 사용)
	=> 상속시 반드시 구현해야 하는, 오버라이딩이 강제화되는 메소드 => 무언가 추가작업이 필요하기에 클래스도 미완성이라고 함
	=> 미완성 클래스이기 때문에 객체생성 불가능하고, 상속으로 완성을 시켜야만 객체로 쓸 수 있다.(자식을)
	=> 객체로는 안되지만 레퍼런스 변수 자료형으론 사용 가능 (후손 클래스가 완성시키면 다형성으로 받을 수 있도록)
	=> ★ 추상 메소드는 static과 사용 불가능하다. static은 모두가 공유하는것이지만 추상 메소드는 상속된 클래스만 접근 가능한것이기 때문이다.

추상 클래스는 정형화된 틀을 유도할때 사용


인터페이스
상수형 필드와 추상 메소드만을 작성할 수 있는 추상 클래스의 변형체
★추상 메소드만 따로 모아놓은것
어짜피 다 추상 메소드만 있기 때문에 public abstract 생략 가능하다.
어짜피 다 상수형 필드만 있기 때문에 public static 생략 가능하다

[접근제한자] interface 인터페이스명{}

인터페이스 vs 추상클래스
1. 인터페이스는 추상메소드만, 추상클래스는 일반메소드 포함 가능
2. 추상클래스는 필요한 기능 정도만 물려주고 싶을때 사용
3. 인터페이스는 정형화를 강제하고자 할때 사용
4. 인터페이스는 다중상속 가능
5. 둘다 객체 생성은 안되나 참조형 변수 자료형으로는 사용 가능.
6. 추상클래스는 extends로 구현, 인터페이스는 implements로 구현


텅 빈 인터페이스를 마커 인터페이스라고 한다.

interface가 다중상속이 가능하다는것은 : 
	interface 는 다중상속을 받을 수도 있고(extends) -> ★인터페이스끼리 틀을 주고받는건 상속으로 한다.
	한 클래스에 다수가 상속을 할 수도 있다는 의미.

한 클래스에서 상속과 구현(implements)가 다 이루어질 수 있다. 물론 이 경우 상속은 1번만 가능

★클래스에서 인터페이스를 가져오는것은 implements를 쓰고(다중 구현 가능),
★인터페이스에서 인터페이스를 가져올땐 extends를 쓴다(다중 상속 가능)
implements는 말그대로 구현하는 건데 interface는 추상화가 더 가미된 아이인데 구현을 한다? 말이 안되죠

		Parent[] pArr = new Parent[4];

		pArr[0] = new Child1();
		pArr[1] = new Child2();
		pArr[2] = new Child2();
		pArr[3] = new Child1();
		
		for(int i = 0; i < pArr.length; i++) {
			if (pArr[i] instanceof Child1) {
				((Child1)pArr[i]).printChild1();
			}
			else if (pArr[i] instanceof Child2) {
				((Child2)pArr[i]).printChild2();
			}
		}

