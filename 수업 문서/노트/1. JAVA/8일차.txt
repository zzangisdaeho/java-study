배열 :

	같은 자료형의 변수를 묶어놓은것

	배열은 인덱스 번호 0부터 시작하함


배열 선언 :	자료형[] 배열명;(대부분 자료형 뒤에 [] 붙임. []붙은것까지가 자료형이다 배열이니까)||
		자료형 배열명[]
		선언 하면 스택에 공간이 생긴다.

배열 할당 :	자료형[] 배열명 = new 자료형[배열크기] ||
		자료형 배열명[] = new 자료형[배열크기]



int a; 변수 선언시 stack 공간에 a라는 공간이 하나 생긴다.
a = 10; 할 시 stack 내 a라는 공간에 10이 들어간다.

마찬가지로
int[] arr; 변수 선언시에 stack에 a공간이 하나 생긴다
하지만 arr은 배열인데 반해 stack의 공간은 하나로써 배열을 넣을 수 없다.

new int[3]을 통해 heap에 공간을 3개 만든다. 이 공간묶음엔 주소가 존재하고
대입 연산자를 통해 arr이라는 stack 변수로 주소를 보내여 참조할 수 있도록 한다. 
(그래서 배열변수 arr은 참조 변수이다)
참조 주소에서 동 호수를 입력하듯 index값을 입력하면 heap의 몇번째칸인지 찾아갈 수 있다.



참조형 자료형은 결국 주소값을 가지고있는 자료형이다.
참조형 자료형들은 결국 다 클래스를 가지고 일컷는 말인데,
(참조형 자료형은 클래스를 가지고 와서 쓰기 때문)
그 클래스들을 내가 사용하기 위해서 생성하려면 객체생성이란걸 해야한다.                                  
(그래서 run클래스에서 다른 클래스를 가져와서 사용할때 new를 써서 참조형 자료형으로 만드는것.)
(new를 사용하면 인스턴스를 heap에 만드는 역할을 한다)


arr = new int[3];에서 new int[3]은 arr에 주소값을 입력하라는 의미이기도 하다.

arr을 print하면 주소값이 나온다.
arr[0, 1, 2] 인덱스를 입력해야 해당 인덱스값을 볼 수 있다.



heap가 만들어지면 주소값이 나타난다.
= 대입연산자 를 통해 해당 메모리의 주소를
arr이라고 stack에 선언한 변수에 넣어준다.
arr은 heap의 주소를 참조하는 변수가 된다.


★★★ new = heap에 공간을 할당해주는 연산자. 공간이 생기면 주소가 나타나기에,
 		주소를 만들어 주는 효과가 있는 연산자로 볼 수도 있다.
		그러니까 객체 만들때는 필수로 들어갈 수 밖에 없다.


0<= math < 1
0<= math*40 < 40
6<= math*40+6 < 46

arr.length => 배열의 길이를 구하는 변수. 변수라서 ()가 안붙는다.
(string.length()에서는 메소드라서 ()가 붙었다)


heap 주소값 실행시
(메모리주소는 아니고 자바에서 배정한 주소가 보임)
주소값에 I@ 면 int형이다
주소값에 D@ 면 double형이다
lang.String 이면 String형이다


boolean의 기본값 : false
char의 기본값 : ' ';
int의 기본값 : 0; (0이 false. 내용 없음(null아님) 이 fasle이다는 아니다. 공허임. 그러니까 기본값자료형들 기본값은 false라고)


배열의 단점.

배열은 크기가 한번 정해지면 변경 불가능험
(같은 주소에선 변경 불가능. 새로운 공간이 생기고 새 주소가 변수로 넘어갈 뿐)
같은 자료형만 넣을 수 있음.

arr = null; 입력시 heap의 주소를 버리기에 연결이 끊기게된다.
arr 은 int자료형이 아니라 int[] 자료형이어서 (주소를 갖는 공간이어서)(int와 int[]는 다르다)
null이 입력이 가능한것이다. null은 주소값에만 입력 가능하고,
int[] arr은 주소값을 갖는 참조 변수이기에 (클래스와 연결되는것) 가능.

참고 ) String에 null을 입력 가능한것은
String이라는 참조자료형 자체가 참조자료형(클래스와 연결됨)이기 때문이다.
별도로 객체를 생성하며 쓰진 않지만, String 이라는 참조 자료형 자체가
String관련 클래스 풀 안에서 자동으로 객체를 생성하여 가져올 수 있도록 설계가 되어있는 특수케이스이기에
가능한 것이다.



Arrays -> 배열을 쓸떄 사용하기 좋은 메소드들이 모인 클래스
sort도 이곳에 속하며 여러 자료형에 사용 가능하다.
근데... ㅅㅂ reverse가 없어 ㅅㅄㅄㅂ -> 새로운 배열2 를 만들어서 꺼꾸로 넣어주는 수 밖에 없다.


얕은 복사 : 객체의 '주소값만' 복사하여 한 객체를 두 변수가 참조하는것. (공용사용, 서로 종속적)

깊은 복사 : 같은 값을 가진 객체를 새로 생성하여 각 변수가 자신만의 주소를 갖는것 (개별사용, 서로 독립적)
		객체슬 생성 후 값만 똑같이 가져온다고도 볼 수 있다.

깊은 복사 방법 1 : System.arraycopy()
메소드( )안에 있는 값을 매개변수라고 한다.

		System.arraycopy(src, srcPos, dest, destPos, length);
		// src		: 원본 배열
		// secPos	: 원본 배열에서 복사할 시작 위치
		// dest		: 복사 배열
		// destPos	: 복사 배열에서 붙여넣을 시작 위치
		// length	: 복사 길이

깊은 복사 방법 2 :  Arrays.copyOf

		int[] originArr = {1,2,3,4,5};
		int[] copyArr = new int[originArr.length*2];
		
		copyArr = Arrays.copyOf(originArr, originArr.length);

		copyOf는 배열을 만드는 메소드다.
		 copy라는 변수의 배열을 제작 후 return으로 copy를 돌려주어 돌려주어 최종적으로
		copyArr = copy = (heap내 배열) 가 되어 copyArr에 copy의 주소값을 넣어준다.