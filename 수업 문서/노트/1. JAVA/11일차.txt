전역변수  = 메소드 밖 클래스 안
전역변수라고 클래스 안에서 맘대로 쓸 수 있는건 아니고, 클래스 안에서 전역변수 를 선언한 줄 아래부터 사용 가능.
전역변수 == 맴버변수 == 맴버필드 == 필드 == ★인스턴스 변수(인스턴스가 생겨야만 쓸 수 있는 변수)
[static예약어 사용시 ★클래스 변수라 함 (클래스만 생성해도 사용 가능허다)]

인스턴스변수는 클래스 안에서 (매소드를 통하지 않는한) 증감이 안된다.
그래서 인스턴스변수를 클래스 안에서 바꾸고 싶을 때 초기화블럭을 사용한다.
변수에 값을 대입(초기화) 해주는 블럭


사용법
{필드 = 초기값} (클래스변수도 인스턴스 블럭 안에서 초기화 가능)
인스턴스변수는 객체형성을 하면서 메모리에 올라가고 이때 필드에서 초기화 되는데,
여기서 static을 써도 항상 메모리에 있기 때문에 문제없이 초기화 가능
★인스턴스 초기화 블럭은 객체 생성을 할 때 마다 사용된다(초기화 된다).

static{필드 = 초기값} (클래스 블럭에 인스턴스 변수 초기화 불가능)
static은 실행되자마자 static에 올라가 있어야 하는데,
인스턴스변수는 객체형성을 해야 메모리에 올라간다 그러니까 사용 불가능
★static 초기화 블럭은 맨 처음 프로그램 실행시 딱 한번만 사용된다


★전역변수 : 초기화 안해도 ㄱㅊ
지역변수 : 초기화 필수

상속 : 후손 클래스에게 필드나 메소드를 물려주는것 extends

자바는 필드에 private로 캡슐화하는게 무언의 규칙이래

디자인 패턴 배울꺼 : MVC, Singleton


MVC패턴

M V C 각각은  패키지
알기 쉬워 유지보수와 협업이 원만해진다.

	M : Model
	- data
	- 클래스는 구조체로 데이터를 보관하는 공간 역할을 할 것. 
	- vo(value object) dao(data access object)
	- dao : 내가 직접 데이터배이스와 연결이됨 (jdbc 할때 배운다) (영구저장)
	- vo : 데이터배이스와 연결은 안되고 값들을 임시로 저장해놓는 역할 (일시저장)
	- 
	
	V : View
	- screen
	- 사용자에게 보여줄 화면단을 모아놓음. 
	-	
	
	C : Controller
	- function
	- 기능들의 집합
	-	


Static 예약어 : static 메모리 영역에 올라감 (정적 메모리 영역)
		같은 타입의 여러 객체가 공유할 목적의 필드에 사용하며,
		프로그램 start시에정적 메모리 영역에 자동 할당되는 맴버에 적용
		

		메모리 위치에 상관 없이 Static 영역은 선언 된 변수명에 따라
		★해당 메모리공간이 어디서든 모두에게 공유된다.
		이러한 공유의 성격때문에 static은 보통 private 붙이지 않는다. public을 쓴다.
		보통 변하지 않는 상수로 사용한다. pulic static final

		
		프로그램 시작부터 종료까지 알아서 메모리 영역에 상시 대기하고 있기 때문에
		객체생성이 필요없다. 그냥 클래스. 해서 들어가면 된다.
		객체생성 하는것은 heap에 올리기 위해서지만 static은 객체완 다르게 항상 메모리에 올라가 있기 때문

		메인 메소드 안에 있는것은 지역변수인데, static은 클래스변수이기 때문에
		static은 메소드 안에 들어갈 수 없다.
		지역변수는 해당 지역에서만 쓸 수 있어야 하는데, static은 어디서든 공유될 수 있어야 하기 때문.
		지역변수는 stack에 생겨야 하는데, static은 static에 생기기 때문.
		stack은 메소드가 실행될때만 변수를 실행시키고 지우는공간인데 static은 실행종료때까지 살아야 하기 때문
		


Static을 남발하면 안되는 이유 : 프로그램 시작부터 프로그램 종료까지 Static영역에 머무른다.
				그래서 무겁고 느려질 수 밖에 없다.


참조 변수를 다르게하여 객체를 생성하면, heap 메모리에 두개의 주소가 만들어지기 때문에
독립적으로 객체가 움직인다.



생성자

	객체를 만들어주면서 매개변수가 있을시 동시에 필드를 초기화시켜주는 역할
	생성자는 일종의 메소드로 ( ()가 있으니까) , 전달된 초기 값(매개변수)을 받아서 객체의 필드에 기록

	생성자의 선언은 메소드 선언과유사하나 반환 값이 없으며(void, int 같은 반환값이 없다)
	★★★생성자명을 클래스명과 똑같이 지정해주어야 함. 규칙임. 안그러면 에러남. 꼬우면 자바 제작자한테 따지셈.
	★★★메소드와 유사하기 때문에 생성자 수행문에 변수 지정해줘봐야 지역변수임 ㅋ 지역 벗어나면 못씀요
		심지어 그 클래스 객체로 생성해도 지역 벗어났다고 안따라감 ㄷㄷㄷㄷ


	매개변수가 없는 생성자는 기본생성자 (default) 라고 부름. JVM에 의해 안써도 생성됨.
	아 참고로, 기본생성자 Poducet(){ }를 수동으로 만들 때 { } 안에 수행문 사용 가능.
	매개변수가 없으니까 기본생성자라고 부르지만 수행문은 쓸 수 있다고 그냥 그렇다고.

	매개변수가 있는 생성자는 매개변수 생성자라고 부름. 써야 생성됨. 쓰면 기본생성자 자동생산 안됨.


오버로딩 ( != 오버라이딩)

	한 클래스 내에 동일한 이름의 메소드를 여러 개 작성하는 기법
	생성자 생성시에도 사용 가능.
	같은 메소드 이름에 다른 매개변수의 개수나 타입(자료형을 말하는거. 변수명은 의미 없당)을
	혹은 다른 순서의 매개변수를 넣어서 만든다.



날짜 관련 코딩에선 Date라는 클래스를 사용한다 (참조 자료형)


this. => 레퍼런스 변수 (주소를 담고있슴)(참조변수)
	★나에 대한 (현재 내가 속한 곳의) 주소값을 갖고 있다는 의미


	레퍼런스 변수 == 참조변수 == 객체의 메모리 주소
	생성 될 객체의 주소를 갖기 때문에 인스턴스 자체로 봐도 된다.
	그러니까 this.userId는 객체(클래스)의 userId를 말하는것으로 맴버변수를 가르킨다.

	ex) ^는 전역변수 #은 지역변수

		public User(String userId#) {
		(this.userId)^ = userId#;
		}

	=
		User us = new User();
		(us.userId)^ = "userId#"

		여기서 this. 는 us. 을 가르킨다고 보면 되는것 개쉽다

	인스턴스 자신을 가르키는 예약어. (매개변수 자신을 가리킨다고 생각해도 무방)
	
	
this() => 자기자신의 생성자를 호출함
	생성자 (내가 속한 클래스 안에 있는생성자들을 같고 있슴)
	★보유하고 있는 매개변수 종류, 갯수로 판단함 (동일한 파라미터 객체를 가진 함수를 호출)
	변수명과 상관없이 자료형과 순서와 갯수만 같으면 된다
	★판단 기준이 (String Stiring int) 와 같이 자료형과 갯수와 순서만 보고 해당 형의 생성자를 찾는 구조
	this생성자로 다른 생성자를 불러올때는 항상 맨 첫줄에 있어야 헌다.


	
	매개변수가 같은 생성자를 부를때도 this 쓸 수 있싐
	
	ex)

		public User(String userId) {
			this.userId = userId;
		}
	
		public User(String userId,String userPwd,String userName) {
	//		this.userId = userId;
			this(userId);
			this.userPwd = userPwd;
			this.userName = userName;
		}
	
		public User(String userId,String userPwd,String userName, Date enrollDate) {
	//		this.userId = userId;
	//		this.userPwd = userPwd;
	//		this.userName = userName;
			this(userId, userPwd, userName);
			this.enrollDate = enrollDate;
		}
	

 자료형  기본값
boolean  false 
char '\u0000'  
byte 0  
short 0  
int 0   
long 0L   
float 0.0f  
double 0.0d 또는 0.0   
참조형 변수 null
