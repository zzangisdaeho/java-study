모든 if문이 switch로 전환될 수 없음
(switch는 조건식의 결과가 정수 또는 문자, 문자열일때만 사용 가능하다는 제약 있기 때문)

모든 switch문은 if문으로 전환 가능

if문이 switch문을 담고있음.


for (초기식; 조건식; 증감식){
	수행될 문장}

1. 초기식과 조건식 비교 -> true라면 수행문장 실행

2. 증감식 수행 후 값을 조건식과 비교 -> true라면 수행문장 실행

3. 2번 프로세스 를 조건식이 false가 될 때까지 반복 실행

초기식 -> 조건식 -> 수행 -> [(증감식 -> 조건식 -> 수행)true일 경우 반복]
				 -> 증감식 -> 조건식 ->false일시 out


for (초기식; 조건식; 증감식) 요소들 생략 가능
생략시 수행될 문장에 생략한 요소를 대체할 수 있는 기능을 넣어야 함.

초기식, 조건식, 증감식은 모두 for 안에서의 지역변수이다. for 안에서만 쓸 수 있다.
★다만 여기서 for 의 범위는 중첩된 조건문(제어문, 반복문) 까지인건 센스인거 RG?


for 문도 중첩 사용 가능
3번 도는 for문(a) 안에 5번 도는 for문(b)이 있을시.
a한번단 b5번 실행하여 총 b는 3x5 = 15번 실행됨.
b문 완료 후 a문의 수행문장이 있다면 같이 실행
근데 5번 이상 중첩사용한거라면 뭔가 잘못짠거래


★★★지역변수에서 전역변수(맴버변수)와 같은 변수명을 선언하고 사용하여 변수 데이터값을 변화해도 전역변수 자체가 변하진 않는다.

ex) A 메소드에서 전역변수가 있는데 같은 변수명을 지역변수로 선언하여 바꿔써도 B메서드에선 변화하지 않은 전역변수를 사용할 수 있다
	★하지만 전역변수명과 같은 지역변수를 선언할시 해당 메소드에선 지역변수를 우선으로 사용한다 (거주민 우선의 원칙)	

	전역변수 a가 있는데, 지역변수 a를 선언하면
	변수값은 같을지라도, 메모리주소가 다르기에 전역변수a와 지역변수 a는 독립적인 값이 된다.

ex2) 하지만 전역변수 자체를 가져와서 변화시키면 B메서드에선 변화한 값을 받게 된다.
	전역변수 a 메모리가 변하기 때문


	1. 전역변수(맴버변수) c = 10을 기존에 선언했을시

	public void prac1() {
		c = 3;			-> 전역변수 c가 3이 됨
		System.out.println(c);	-> 전역변수 c가 3가 출력됨
		int c = 5;		-> 지역변수 c를 선언하고 이 값을 5로 넣음 (추후 해당 메소드에서 c를 입력시 지역변수 c가 사용됨. 지역민 우선)
		System.out.println(c);	-> 지역변수 c값 5가 출력됨
	}
	public void prac2() {
		System.out.println(c);	-> 전역변수 c값인 3이 출력됨. (prac1에서 전역변수 c를 변화시켰기 때문)
	}



	2. 전역변수(맴버변수) c = 10을 기존에 선언했을시

	public void prac1() {
		int c = 5;		-> 지역변수 c를 선언하고 이 값을 5로 넣음 (추후 해당 메소드에서 c를 입력시 지역변수 c가 사용됨. 지역민 우선)
		System.out.println(c);	-> 지역변수 c값 5 출력
	}
	public void prac2() {		
		System.out.println(c);	-> 전역변수 c값 10 출력 (따로 지역변수를 선언하지 않을 경우 전역변수를 가져오기 때문)
	}
	


★ Math.random()
		0 <= Math.random() < 1
		0 <= Math.random() * 10 < 10
		0 <= (int)(Math.random() * 10) < 10   => 0~9 정수만 나옴
		1 <= (int)(Math.random() * 10) + 1 < 11   => 1~10 정수만 나옴



while문
	
	증감식 or 분기문을 안쓰면 영원히 반복된다(무한 true) ㅎㅎㅎ

	for문과 다르게 조건식에 자료형선언 불가능하다

	횟수가 정해지면 for문, 조건(true false)이 중요할땐 while문, 분기형이 있을시 if문이 좋겠다

	while 중첩문 쓸때 중첩 속 while의 변수는 초기화 안된다.(지역변수니까 while 안에선 당연히 값이 유지됨)
	재충첩 시키기 전에 초기화 해줘야함



do while문
do{} 다음에 while{}에서 ; 빼먹으면 에러뜬다

return;
실행 된 메소드 내 while 중에
return; 을 만나면 main메소드로 돌아간다

break는 최근 반복문을 나가는것이지만
return은 해당 메소드 자체를 나간다

스택구조에서 처음에 들어가는게 main()이고, 그 위에 method10()이 실행됨
	-> method10() 실행 중 return을 만나면 아래 있는 stack 메모리에 있는 main()에 돌아감
	-> 결과적으로 method10() 종료
꼭 main()으로 돌아가는것이 아닌, return이 있는 메소드 를 호출한 곳으로 돌아간다.

ex ) main() 메소드 안에 method10() 안에 methodtest()가 있음
	methodtest() 실행 중 return을 만나면,
	return 아래 어떤 코드가 있어도 무시하고 method10()으로 돌아간다.
	사실 return이 포함된 코딩에서 return 뒤에 있는 코딩은 에러가뜬다. 어짜피 실행 안되는코드이기 때문.


break;
break가 존재하는 반복문을 빠져나간다.
2중첩 for문을 가정했을시 중첩된 for에 break를 쓰면 두번째 for문을 탈출하고 첫번째 for문에 해당하는 break는
첫번째 for문을 탈출한다(반복문 종료)
★if는 반복문이 아니라 조건문이기 때문에 if 안에 break가 있더라도 if를 포괄하고 있는 마지막 반복문이 끝난다.
중복 반복문에서 break로 빠져나올경우 위에서 다시 시작이 아니라 그 아래로 흘러간다. 당연한가;



continue;
continue는 반복문에서만 사용 가능하다. for와 while에서 쓸 경우 기능이 약간 다르다.

for 문에서 사용할 경우 해당 반복 페이즈의 continue 이하 코드를 스킵하고 ★[증감식으로 이동]하여 다음 페이즈를 발동시킨다.
continue 이전의 값은 정상 반영된다.

while 문에서 사용할 경우 해당 반복 페이즈의 continue 이하 코드를 스킵하고 ★[조건식으로 이동]하여 true false를 판별 후
반복문을 재실행 시킨다. continue 이전의 값은 정상 반영되기 때문에 continue 이전에 조건식을 벗어날 코드가 없다면 무한반복된다.
그러니까 메모리 터트리지 말고 조건식 벗어날 코드를 continue 전에 써놓자!

ex)		int num = 0;
		int sum = 0;
		while (num<10) {
			num++;
			 // ★여기서 탈출 증분식은 이 num++가 될 것이다. 이 코딩이 없다면 0이 if문에 들어가서 다시 조건식으로 돌아가며 num은 0의 값을 가지고 무한 반복된다
			System.out.println(num);
			if (num%2 == 0) {
				continue;
			}
			sum += num;
		}
		System.out.println(sum);


★★★문자열의 길이를 구할때는 "문자열".length() 를 사용한다. 소괄호니까 메소드다