상속

부모클래스가 자식클래스에게 부모의 ★필드나, 메소드를 복사하여 물려주는것
자식클래스는 부모의 필드나 메소드를 자신의 것처럼 그냥 사용 가능하다
(★생성자, 초기화 블록 상속안됨 - 생성자는 클래스 고유 기능이고, 초기화 블록이 상속되다가 static이 상속되면 망하니까?)
그렇기 때문에 자식이 갖고있는 맴버의 개수는 부모가 가지고있는 맴버의 개수보다 같거나 많다.

부모 생성자를 사용 가능하지만 이는 자식클래스 객체 생성시 부모클래스 객체가 먼저 만들어지고
그 위에 자식객체가 씌워지는것. 자식 클래스 객채 생성시 1회성 사용으로 상속된것으로 보긴 힘들다.
부모클래스 생성자를 사용시 super()를 사용한다.
이 경우 this()를 사용할 수 없게되지만, this()를 사용하여 가져올 생성자에 super()를 사용했을것이므로
문제 없다.

부모클래스를 관리하면 상속도 관리하는것이기에 여러 클래스를 체계적으로 관리하기 용이.


모든 클래스는 Object클래스의 후손. 자바가 그냥 그렇게 만들어져있다.
덕분에 Object의 메소드를 어느 클래스에서나 사용 가능하다.


오버라이딩( != 오버로딩)
	메소드 재정의. 부모의 메소드를 자식이 재정의해서 사용하겠다

	메소드 헤드라인 위에 ★Annotation이나 ★@Override 표시해야 함
	해당 표시가 있어야만 컴파일 에러를 볼 수 있다.

	접근 제어자를 부모 것보다 같거나 넓은 범위로 변경 가능

오버라이딩은
1. 상속이 먼저 정의되어 있어야 함. (상속이 전제됨)
2. 메소드 이름 동일
3. 매개변수의 개수, 타입 동일
4. 리턴 타입 동일
	=> 걍 다 동일해야함
- private 메소드 오버라이딩 불가 (가져올 수 없음)
- final 메소드 오버라이딩 불가 (final은 종단의 의미로써 변경 할 수 없기 때문에 재정의 불가능)


final은 변수, 메소드, 클래스에 붙을 수 있다.
변수 : 상수
메소드 : 오버라이딩 불가
★클래스 : 상속이 불가능한 클래스



자식 extends 부모 : 자식이 부모걸 상속받아 확장한다.

상속된 클래스를 통해 부모의 필드를 변경시. 부모클래스의 필드에는 영향을 주지 못함.
자식클래스 객체생성을 하면, 독립적인 부모 영역을 품은(자식 클레스 매모리 안에 부모클래스 메모리가 속해져있음) 자식클래스가 메모리에 생긴다
주소를 참조하는게 아니고 깊은 복사의 개념으로 보아야 한다. 
(단, 실행 이후 코드를 통한 부모클래스의 맴버변수 변화는 자식클래스에게 영향을 끼치지 못한다)
(즉, ★처음에 코딩 한 부모의 맴버변수 틀 그대로만 가져오는것) 


자바는 상속을 한명한테서만 받을 수 있다 (단일 상속만 지원)

super.  => 부모의 레퍼런스 변수
super() => 부모의 생성자를 불러오는 역할


toString : 해당 객체의 대표값을 반환 => 대표값 : 객체의 주소값
	하지만 주소값이 궁금하지 않은 우리는 inform()을 toString으로 변화시켜서 사용!
	모든 클래스의 조상인 Object클래스에 있는 toString 메소드를 변화시켜(오버라이딩)
	출력용으로 사용!
	★근데 toString이 주소값을 의미하는 함수여서 레퍼런스 변수를 인쇄해도 주소값이 나오지 않고
	출력용으로 지정한 값이 나온다. 어짜피 주소값 쓰지도 않는데 상관없을듯


부모메소드가 여럿일 경우..

상관 없음..
마지막 상속된 부모가 윗 부모의 모든 전역변수와 메소드를 상속해왔기 때문에
몇번째 되물림이든 직전 부모가 모든걸 가지고 왔기 때문이다.
몇번째 되물림이든 자식 클래스는 부모의 모든 메소드와 전역변수를 가지고 오기 때문에
(private 접근제어자 메소드와 전역변수도 가져온다. 우회해서 접촉해야 하지만..)
super. 없이 자신의 메소드와 전역변수처럼 사용 가능
하지만 코딩 습관으로 super. 는 붙이자 안그러면 다른사람이 헷갈려한다. 뒷통수맞는다.


static이 붙은 대표적인 메소드
Math. 안에 있는 pow, random, max, min 등